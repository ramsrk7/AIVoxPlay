<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Echo with Interrupt</title>
  <style>
    /* Global styles */
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background: #f0f2f5;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #333;
    }

    button {
      background-color: #4CAF50;
      border: none;
      border-radius: 4px;
      color: white;
      padding: 12px 24px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      margin-bottom: 16px;
    }
    button:hover {
      background-color: #45a049;
    }

    audio {
      width: 300px;
      margin-top: 16px;
    }

    /* Indicator circle */
    #indicator {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #4CAF50;
      margin-bottom: 24px;
      /* Default paused */
      animation: bounce 0.4s infinite alternate paused;
    }

    /* Bouncing when listening */
    .listening {
      animation-play-state: running;
    }

    @keyframes bounce {
      from { transform: translateY(0); }
      to   { transform: translateY(-20px); }
    }

    /* Pulsing when playing */
    .playing {
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%   { transform: scale(1); }
      50%  { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
  <div id="indicator"></div>
  <button id="start">Start Echo</button>
  <audio id="player" controls></audio>

  <script>
    const WS_URL = "ws://localhost:8001/ws/realtime";
    let ws, audioCtx, micStream, source, processor;
    let listening = true, playing = false;
    let micBuffer = [], chunks = [];
    const VAD_THRESH = 0.02;

    const indicator = document.getElementById('indicator');

    document.getElementById("start").onclick = () => {
      if (ws) return;
      ws = new WebSocket(WS_URL);
      ws.binaryType = "arraybuffer";
      ws.onopen    = initMic;
      ws.onmessage = onWSMessage;
    };

    function initMic() {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(strm => {
          audioCtx   = new AudioContext();
          micStream  = strm;
          source     = audioCtx.createMediaStreamSource(strm);
          processor  = audioCtx.createScriptProcessor(4096,1,1);

          source.connect(processor);
          processor.connect(audioCtx.destination);
          processor.onaudioprocess = e => {
            const data = e.inputBuffer.getChannelData(0);
            let sum = 0;
            for (let x of data) sum += x*x;
            const rms = Math.sqrt(sum / data.length);

            // Toggle bouncing
            if (rms > VAD_THRESH && listening) {
              indicator.classList.add('listening');
            } else {
              indicator.classList.remove('listening');
            }

            const pcm = new Int16Array(data.length);
            for (let i=0;i<data.length;i++){
              let s = Math.max(-1,Math.min(1,data[i]));
              pcm[i] = s<0? s*0x8000 : s*0x7FFF;
            }

            if (listening) {
              ws.send(pcm.buffer);
            } else {
              micBuffer.push(pcm.buffer);
            }

            if (playing && rms > VAD_THRESH) {
              ws.send(JSON.stringify({type:"cancel_audio"}));
              playing = false;
              listening = true;
              for (let b of micBuffer) ws.send(b);
              micBuffer = [];
            }
          };
        })
        .catch(console.error);
    }

    function onWSMessage(evt) {
      if (typeof evt.data === "string") {
        const msg = JSON.parse(evt.data);
        if (msg.type === "audio.complete") {
          playing = true;
          listening = false;
          indicator.classList.remove('listening');
          indicator.classList.add('playing');
          playBack();
        }
        if (msg.type === "audio.cancelled") {
          chunks = [];
        }
      } else {
        chunks.push(evt.data);
      }
    }

    function playBack() {
      const blob   = new Blob(chunks, {type:"audio/wav"});
      const url    = URL.createObjectURL(blob);
      const player = document.getElementById("player");
      player.src    = url;
      player.play();
      player.onended = () => {
        chunks = [];
        playing = false;
        listening = true;
        indicator.classList.remove('playing');
        for (let b of micBuffer) ws.send(b);
        micBuffer = [];
      };
    }
  </script>
</body>
</html>
